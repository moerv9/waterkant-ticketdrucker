This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-01T16:07:04.512Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
printer_manager/
  connection.py
  print_module.py
  scanner.py
static/
  css/
    style.css
  js/
    main.js
templates/
  index.html
app.py
requirements.txt

================================================================
Files
================================================================

================
File: printer_manager/connection.py
================
import socket
import subprocess
import os
import re

def test_printer_connection(method, address, model):
    """Test if we can connect to the printer"""
    if method == "wifi":
        # Test TCP connection
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(2)
        try:
            result = s.connect_ex((address, 9100))
            s.close()
            return result == 0
        except:
            s.close()
            return False
    elif method == "bluetooth":
        # Test Bluetooth connection using system tools
        try:
            if os.name == 'posix':  # macOS or Linux
                # For macOS, use system command to check if device is visible
                if 'darwin' in os.sys.platform:  # macOS
                    result = subprocess.run(["system_profiler", "SPBluetoothDataType"], 
                                          capture_output=True, text=True, timeout=5)
                    return address.replace(':', '-').lower() in result.stdout.lower()
                else:  # Linux
                    result = subprocess.run(["bluetoothctl", "info", address], 
                                          capture_output=True, text=True, timeout=5)
                    return "Device" in result.stdout and not "not available" in result.stdout
            else:  # Windows
                # On Windows, we can't easily check, so we assume it's available if it was found
                return True
        except:
            # If command-line tools fail, assume it might be available
            return True
    elif method == "usb":
        # For USB, we'll rely on the brother_ql list command
        try:
            result = subprocess.run(["brother_ql", "list"], capture_output=True, text=True)
            return address in result.stdout
        except:
            return False
    elif method == "system":
        # For system printers, check if the printer exists in the system
        try:
            if os.name == 'posix':  # macOS or Linux
                result = subprocess.run(["lpstat", "-p", address], 
                                      capture_output=True, text=True, timeout=5)
                return result.returncode == 0
            else:  # Windows
                # For Windows, use wmic to check printer existence
                result = subprocess.run(
                    ["wmic", "printer", "where", f"name='{address}'", "get", "name"],
                    capture_output=True, text=True, timeout=5
                )
                return address in result.stdout
        except:
            return False
    
    return False

def create_print_function(printer_config):
    """Generate the appropriate print_name function based on connection method"""
    if printer_config["method"] == "wifi":
        return f"""
def print_name(path):
    os.environ['BROTHER_QL_PRINTER'] = "tcp://{printer_config['address']}"
    os.environ['BROTHER_QL_MODEL'] = "{printer_config['model']}"
    try:
        result = subprocess.run(["brother_ql", "print", "-l", "62", path], 
                               capture_output=True, text=True, timeout=10)
        if result.returncode != 0:
            print(f"Error printing: {{result.stderr}}")
            return False
        os.remove(path)
        return True
    except Exception as e:
        print(f"Exception during printing: {{e}}")
        return False
"""
    elif printer_config["method"] == "bluetooth":
        return f"""
def print_name(path):
    # For MacOS, try to use system printing capabilities
    try:
        # Get printer name from model
        printer_name = os.environ.get('BROTHER_QL_MODEL', 'QL-820NWB')
        
        # Try the lp command first (MacOS and Linux)
        result = subprocess.run(["lp", "-d", printer_name, path], 
                               capture_output=True, text=True, timeout=10)
        
        if result.returncode != 0:
            # Fallback to brother_ql with direct Bluetooth printing if supported
            os.environ['BROTHER_QL_PRINTER'] = "bluetooth://{printer_config['address']}"
            os.environ['BROTHER_QL_MODEL'] = "{printer_config['model']}"
            result = subprocess.run(["brother_ql", "print", "-l", "62", path], 
                                   capture_output=True, text=True, timeout=10)
                                   
        if result.returncode != 0:
            print(f"Error printing: {{result.stderr}}")
            return False
            
        os.remove(path)
        return True
    except Exception as e:
        print(f"Exception during printing: {{e}}")
        # Keep the file so user can print manually
        print(f"Image saved at: {{path}}")
        return False
"""
    elif printer_config["method"] == "usb":
        return f"""
def print_name(path):
    os.environ['BROTHER_QL_PRINTER'] = "{printer_config['address']}"
    os.environ['BROTHER_QL_MODEL'] = "{printer_config['model']}"
    try:
        result = subprocess.run(["brother_ql", "print", "-l", "62", path], 
                               capture_output=True, text=True, timeout=10)
        if result.returncode != 0:
            print(f"Error printing: {{result.stderr}}")
            return False
        os.remove(path)
        return True
    except Exception as e:
        print(f"Exception during printing: {{e}}")
        return False
"""
    elif printer_config["method"] == "system":
        return f"""
def print_name(path):
    # Use system printing capabilities for a printer installed on the system
    try:
        # Use the printer name directly with lp command
        result = subprocess.run(["lp", "-d", "{printer_config['address']}", path], 
                               capture_output=True, text=True, timeout=10)
        
        if result.returncode != 0:
            print(f"Error printing: {{result.stderr}}")
            return False
            
        os.remove(path)
        return True
    except Exception as e:
        print(f"Exception during printing: {{e}}")
        # Keep the file so user can print manually
        print(f"Image saved at: {{path}}")
        return False
"""
    else:
        # Default to a function that just saves the file
        return """
def print_name(path):
    print(f"No printer connected. Image saved at: {path}")
    return False
"""

def update_print_module(printer_config):
    """Update the print_module.py file with the correct printing function"""
    # Ensure the printer_manager directory exists
    os.makedirs("printer_manager", exist_ok=True)
    
    with open("printer_manager/print_module.py", "w") as f:
        f.write("""
# Dynamically generated printing module
import os
import subprocess

""" + create_print_function(printer_config))

    # Create init file if it doesn't exist
    init_path = "printer_manager/__init__.py"
    if not os.path.exists(init_path):
        with open(init_path, "w") as f:
            f.write("# Printer manager package\n")

================
File: printer_manager/print_module.py
================
# Dynamically generated printing module
import os
import subprocess


def print_name(path):
    # Use system printing capabilities for a printer installed on the system
    try:
        # Use the printer name directly with lp command
        result = subprocess.run(["lp", "-d", "Brother_QL_820NWB__94ddf8a529c6_", path], 
                               capture_output=True, text=True, timeout=10)
        
        if result.returncode != 0:
            print(f"Error printing: {result.stderr}")
            return False
            
        os.remove(path)
        return True
    except Exception as e:
        print(f"Exception during printing: {e}")
        # Keep the file so user can print manually
        print(f"Image saved at: {path}")
        return False

================
File: printer_manager/scanner.py
================
import socket
import re
import subprocess
import os
import json
import time

def get_network_interfaces():
    """Get all network interfaces and their IP addresses"""
    interfaces = []
    
    try:
        if os.name == 'posix':  # macOS or Linux
            if 'darwin' in os.sys.platform:  # macOS
                # Use ifconfig on macOS
                result = subprocess.run(["ifconfig"], capture_output=True, text=True)
                if result.returncode == 0:
                    current_iface = None
                    for line in result.stdout.splitlines():
                        if ':' in line and not line.startswith('\t') and not line.startswith(' '):
                            # New interface definition
                            current_iface = line.split(':')[0]
                            if current_iface in ('lo', 'lo0'):  # Skip loopback
                                current_iface = None
                        elif current_iface and 'inet ' in line:
                            # IP address for the current interface
                            match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', line)
                            if match:
                                ip = match.group(1)
                                interfaces.append((current_iface, ip))
            else:  # Linux
                # Use ip addr on Linux
                result = subprocess.run(["ip", "addr"], capture_output=True, text=True)
                if result.returncode == 0:
                    current_iface = None
                    for line in result.stdout.splitlines():
                        if line.startswith(' ') and current_iface and 'inet ' in line:
                            match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)', line)
                            if match:
                                ip = match.group(1)
                                interfaces.append((current_iface, ip))
                        elif not line.startswith(' '):
                            match = re.search(r'\d+: (\w+):', line)
                            if match:
                                iface = match.group(1)
                                if iface != 'lo':  # Skip loopback
                                    current_iface = iface
                                else:
                                    current_iface = None
        else:  # Windows
            # Use ipconfig on Windows
            result = subprocess.run(["ipconfig"], capture_output=True, text=True)
            if result.returncode == 0:
                current_iface = None
                for line in result.stdout.splitlines():
                    if 'adapter' in line.lower():
                        current_iface = line.split(':')[0].strip()
                    elif current_iface and 'IPv4 Address' in line:
                        ip = line.split(':')[-1].strip()
                        interfaces.append((current_iface, ip))
    except:
        # Fallback to socket method if command-line tools fail
        try:
            hostname = socket.gethostname()
            ip = socket.gethostbyname(hostname)
            interfaces.append(('default', ip))
        except:
            pass
    
    return interfaces

def scan_wifi_printers():
    """Scan for Brother printers on the network"""
    devices = []
    
    # Get all network interfaces
    interfaces = get_network_interfaces()
    
    for interface, ip_address in interfaces:
        # Get network prefix (e.g., 192.168.1)
        ip_parts = ip_address.split('.')
        network_prefix = '.'.join(ip_parts[:-1])
        
        # Limit scanning to 10 addresses in development to make it faster
        # In production, you'd want to scan the full range
        scan_range = range(1, 20)  # Scan only addresses 1-20 for faster results
        
        for i in scan_range:
            target_ip = f"{network_prefix}.{i}"
            # Skip own IP
            if target_ip == ip_address:
                continue
                
            # Try to connect to port 9100 (printer port) with timeout
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(0.1)
            try:
                result = s.connect_ex((target_ip, 9100))
                if result == 0:
                    # This could be a printer, try to get its name
                    try:
                        host_info = socket.gethostbyaddr(target_ip)
                        hostname = host_info[0]
                        if 'brother' in hostname.lower() or 'ql' in hostname.lower():
                            devices.append({
                                'name': hostname,
                                'address': target_ip,
                                'type': 'wifi'
                            })
                        else:
                            # Even if no Brother in name, might be a printer
                            devices.append({
                                'name': f"Possible Printer at {target_ip}",
                                'address': target_ip,
                                'type': 'wifi'
                            })
                    except:
                        # If we can't get hostname, still add it as a potential printer
                        devices.append({
                            'name': f"Unknown Device at {target_ip}",
                            'address': target_ip,
                            'type': 'wifi'
                        })
            except:
                pass
            finally:
                s.close()
    
    return devices

def scan_bluetooth_printers():
    """Scan for Brother printers over Bluetooth using system commands"""
    devices = []
    
    try:
        if os.name == 'posix':  # macOS or Linux
            if 'darwin' in os.sys.platform:  # macOS
                # On macOS, use system_profiler
                result = subprocess.run(
                    ["system_profiler", "SPBluetoothDataType", "-json"],
                    capture_output=True, text=True, timeout=10
                )
                
                if result.returncode == 0:
                    try:
                        # Parse JSON output
                        data = json.loads(result.stdout)
                        bt_data = data.get('SPBluetoothDataType', [{}])[0]
                        
                        # Look for paired devices
                        paired_devices = bt_data.get('device_title', {})
                        for device_name, device_info in paired_devices.items():
                            if isinstance(device_info, dict):
                                # Check if it's a printer by name
                                if 'brother' in device_name.lower() or 'ql' in device_name.lower():
                                    # Get MAC address
                                    address = device_info.get('device_address', '')
                                    if address:
                                        # Convert address format if needed (replace - with :)
                                        address = address.replace('-', ':').upper()
                                        devices.append({
                                            'name': device_name,
                                            'address': address,
                                            'type': 'bluetooth'
                                        })
                    except json.JSONDecodeError:
                        # Fallback to text parsing if JSON fails
                        for line in result.stdout.splitlines():
                            if 'Address:' in line and ('Brother' in result.stdout or 'QL' in result.stdout):
                                match = re.search(r'Address: ([\w\-:]+)', line)
                                if match:
                                    address = match.group(1).replace('-', ':').upper()
                                    name = "Brother Printer"
                                    devices.append({
                                        'name': name,
                                        'address': address,
                                        'type': 'bluetooth'
                                    })
            else:  # Linux
                # On Linux, use bluetoothctl
                result = subprocess.run(
                    ["bluetoothctl", "devices"],
                    capture_output=True, text=True, timeout=5
                )
                
                if result.returncode == 0:
                    for line in result.stdout.splitlines():
                        if 'Device' in line:
                            parts = line.split(' ', 2)
                            if len(parts) >= 3:
                                address = parts[1]
                                name = parts[2]
                                if 'brother' in name.lower() or 'ql' in name.lower():
                                    devices.append({
                                        'name': name,
                                        'address': address,
                                        'type': 'bluetooth'
                                    })
        else:  # Windows
            # Windows Bluetooth scanning would need PowerShell commands
            # This is a simplified version that might work on some systems
            result = subprocess.run(
                ["powershell", "-Command", "Get-PnpDevice -Class Bluetooth | Format-List"],
                capture_output=True, text=True, timeout=5
            )
            
            if result.returncode == 0:
                current_device = {}
                for line in result.stdout.splitlines():
                    if ':' in line:
                        key, value = line.split(':', 1)
                        key = key.strip()
                        value = value.strip()
                        
                        if key == 'FriendlyName' and ('brother' in value.lower() or 'ql' in value.lower()):
                            current_device['name'] = value
                        elif key == 'DeviceID' and 'name' in current_device:
                            # Try to extract MAC from device ID
                            match = re.search(r'_([\w\&]+)$', value)
                            if match:
                                address = match.group(1).replace('_', ':')
                                current_device['address'] = address
                                current_device['type'] = 'bluetooth'
                                devices.append(current_device)
                                current_device = {}
    except Exception as e:
        print(f"Error scanning Bluetooth: {e}")
    
    # If no devices found but we know the printer model, add a manual option
    if not devices and os.environ.get('BROTHER_QL_MODEL', '').startswith('QL-'):
        model = os.environ.get('BROTHER_QL_MODEL')
        devices.append({
            'name': f"{model} (Manual entry required)",
            'address': "00:00:00:00:00:00",
            'type': 'bluetooth'
        })
    
    return devices

def check_usb_printers():
    """Check for Brother printers connected via USB"""
    devices = []
    
    try:
        # Try to use brother_ql's list command first
        try:
            result = subprocess.run(["brother_ql", "list"], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if line.startswith('usb://'):
                        devices.append({
                            'name': f"Brother USB Printer",
                            'address': line.strip(),
                            'type': 'usb'
                        })
                
                # If devices found, return early
                if devices:
                    return devices
        except:
            pass
        
        # Fall back to system-specific USB detection
        if os.name == 'posix':  # macOS or Linux
            # On macOS or Linux systems
            result = subprocess.run(["lsusb"], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if 'brother' in line.lower() or 'ql' in line.lower():
                        # Parse the USB ID and create a USB path
                        match = re.search(r'ID (\w+):(\w+)', line)
                        if match:
                            vendor_id, product_id = match.groups()
                            # Get the device name
                            name = line.split(f"ID {vendor_id}:{product_id}")[-1].strip()
                            usb_path = f"usb://0x{vendor_id}:0x{product_id}"
                            devices.append({
                                'name': name if name else f"Brother USB Printer",
                                'address': usb_path,
                                'type': 'usb'
                            })
        else:  # Windows
            # Windows USB detection would need more complex PowerShell commands
            # This is a placeholder - would need to be expanded for production use
            pass
    except Exception as e:
        print(f"Error checking USB: {e}")
    
    return devices


# Add this to printer_manager/scanner.py
def get_system_printers():
    """Get list of printers installed in the system"""
    devices = []
    
    try:
        if os.name == 'posix':  # macOS or Linux
            if 'darwin' in os.sys.platform:  # macOS
                # Use lpstat to get printer list on macOS
                result = subprocess.run(["lpstat", "-p"], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.splitlines():
                        if line.startswith("printer "):
                            # Extract printer name
                            printer_name = line.split()[1]
                            
                            # Check if it's a Brother printer
                            is_brother = False
                            info_result = subprocess.run(["lpoptions", "-p", printer_name, "-l"], 
                                                      capture_output=True, text=True)
                            if "brother" in info_result.stdout.lower() or "ql" in info_result.stdout.lower():
                                is_brother = True
                            
                            devices.append({
                                'name': f"System Printer: {printer_name}" + (" (Brother)" if is_brother else ""),
                                'address': printer_name,  # Use printer name as the address
                                'type': 'system'
                            })
            else:  # Linux
                # Use lpstat for Linux as well
                result = subprocess.run(["lpstat", "-a"], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.splitlines():
                        if " accepting requests" in line:
                            printer_name = line.split()[0]
                            devices.append({
                                'name': f"System Printer: {printer_name}",
                                'address': printer_name,
                                'type': 'system'
                            })
        else:  # Windows
            # For Windows, we would use wmic
            try:
                result = subprocess.run(
                    ["wmic", "printer", "get", "name"],
                    capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    for line in result.stdout.splitlines()[1:]:  # Skip header
                        printer_name = line.strip()
                        if printer_name:  # Skip empty lines
                            devices.append({
                                'name': f"System Printer: {printer_name}",
                                'address': printer_name,
                                'type': 'system'
                            })
            except:
                pass
    except Exception as e:
        print(f"Error getting system printers: {e}")
    
    return devices

================
File: static/css/style.css
================
body {
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f5f5f5;
    color: #333;
}

h1 {
    color: #2c3e50;
    text-align: center;
    margin-bottom: 30px;
}

h2 {
    color: #3498db;
    margin-top: 0;
    margin-bottom: 20px;
}

.card {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    padding: 20px;
    margin-bottom: 20px;
}

.connection-status {
    padding: 12px;
    border-radius: 6px;
    margin-bottom: 20px;
    font-weight: bold;
    text-align: center;
}

.connected {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.disconnected {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.searching {
    background-color: #fff3cd;
    color: #856404;
    border: 1px solid #ffeeba;
}

button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 8px;
    margin-bottom: 8px;
    transition: background-color 0.3s ease;
    font-weight: bold;
}

button:hover {
    background-color: #2980b9;
}

button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
}

.device-list {
    max-height: 300px;
    overflow-y: auto;
    margin-top: 15px;
}

.device-item {
    padding: 12px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.device-item:hover {
    background-color: #ecf0f1;
}

.test-print-form {
    margin-top: 20px;
    display: flex;
    flex-wrap: wrap;
}

input, select {
    padding: 10px;
    margin-right: 8px;
    margin-bottom: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    flex-grow: 1;
}

label {
    display: block;
    margin-bottom: 8px;
    color: #555;
}

@media (max-width: 600px) {
    button, input, select {
        width: 100%;
        margin-right: 0;
    }
}

================
File: static/js/main.js
================
/**
 * Printer Connection Manager - Frontend JavaScript
 */

// DOM Elements
const statusElement = document.getElementById('connection-status');
const methodElement = document.getElementById('connection-method');
const addressElement = document.getElementById('connection-address');
const modelElement = document.getElementById('printer-model');
const deviceContainer = document.getElementById('device-container');
const deviceList = document.getElementById('device-list');

// Buttons
const autoConnectBtn = document.getElementById('auto-connect');
const scanWifiBtn = document.getElementById('scan-wifi');
const scanBluetoothBtn = document.getElementById('scan-bluetooth');
const scanUsbBtn = document.getElementById('scan-usb');
const manualConnectBtn = document.getElementById('manual-connect');
const printTestBtn = document.getElementById('print-test');

// Input fields
const manualAddressInput = document.getElementById('manual-address');
const connectionTypeSelect = document.getElementById('connection-type');
const firstNameInput = document.getElementById('first-name');
const lastNameInput = document.getElementById('last-name');

/**
 * Update connection status UI
 * @param {Object} data - Printer connection data
 */
function updateConnectionStatus(data) {
    statusElement.textContent = data.status;
    methodElement.textContent = data.method || 'None';
    addressElement.textContent = data.address || 'None';
    modelElement.textContent = data.model;
    
    statusElement.className = 'connection-status';
    if (data.connected) {
        statusElement.classList.add('connected');
    } else if (data.status.includes('Searching') || data.status.includes('Trying')) {
        statusElement.classList.add('searching');
    } else {
        statusElement.classList.add('disconnected');
    }
}

/**
 * Fetch current printer status
 */
function fetchStatus() {
    fetch('/api/printer/status')
        .then(response => response.json())
        .then(data => {
            updateConnectionStatus(data);
        })
        .catch(error => {
            console.error('Error fetching status:', error);
        });
}

/**
 * Show list of found devices
 * @param {string} type - Device type (WiFi, Bluetooth, USB)
 * @param {Array} devices - List of devices
 */
function showDeviceList(type, devices) {
    // Clear previous list
    deviceList.innerHTML = '';
    
    // Add each device to the list
    devices.forEach(device => {
        const item = document.createElement('div');
        item.className = 'device-item';
        item.textContent = `${device.name} (${device.address})`;
        item.addEventListener('click', function() {
            connectToDevice(type.toLowerCase(), device.address);
        });
        deviceList.appendChild(item);
    });
    
    // Show the container
    deviceContainer.style.display = 'block';
}

/**
 * Connect to a selected device
 * @param {string} method - Connection method
 * @param {string} address - Device address
 */
function connectToDevice(method, address) {
    fetch('/api/printer/connect', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            address: address,
            method: method
        })
    })
    .then(response => response.json())
    .then(data => {
        updateConnectionStatus(data);
        deviceContainer.style.display = 'none';
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

// Event Listeners

// Auto connect to printer
autoConnectBtn.addEventListener('click', function() {
    this.disabled = true;
    statusElement.textContent = 'Searching for printers...';
    statusElement.className = 'connection-status searching';
    
    fetch('/api/printer/auto-connect', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            updateConnectionStatus(data);
            this.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            this.disabled = false;
            statusElement.textContent = 'Connection error';
            statusElement.className = 'connection-status disconnected';
        });
});

// Scan for WiFi printers
scanWifiBtn.addEventListener('click', function() {
    this.disabled = true;
    statusElement.textContent = 'Scanning WiFi network...';
    statusElement.className = 'connection-status searching';
    
    fetch('/api/printer/scan/wifi', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.devices && data.devices.length > 0) {
                showDeviceList('WiFi', data.devices);
                statusElement.textContent = `Found ${data.devices.length} printer(s) on WiFi`;
            } else {
                alert('No WiFi printers found');
                statusElement.textContent = 'No WiFi printers found';
                statusElement.className = 'connection-status disconnected';
            }
            this.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            this.disabled = false;
            statusElement.textContent = 'Scan error';
            statusElement.className = 'connection-status disconnected';
        });
});

// Scan for Bluetooth printers
scanBluetoothBtn.addEventListener('click', function() {
    this.disabled = true;
    statusElement.textContent = 'Scanning Bluetooth devices...';
    statusElement.className = 'connection-status searching';
    
    fetch('/api/printer/scan/bluetooth', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.devices && data.devices.length > 0) {
                showDeviceList('Bluetooth', data.devices);
                statusElement.textContent = `Found ${data.devices.length} printer(s) on Bluetooth`;
            } else {
                alert('No Bluetooth printers found');
                statusElement.textContent = 'No Bluetooth printers found';
                statusElement.className = 'connection-status disconnected';
            }
            this.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            this.disabled = false;
            statusElement.textContent = 'Scan error';
            statusElement.className = 'connection-status disconnected';
        });
});

// Check for USB printers
scanUsbBtn.addEventListener('click', function() {
    this.disabled = true;
    statusElement.textContent = 'Checking USB connections...';
    statusElement.className = 'connection-status searching';
    
    fetch('/api/printer/scan/usb', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.devices && data.devices.length > 0) {
                showDeviceList('USB', data.devices);
                statusElement.textContent = `Found ${data.devices.length} printer(s) on USB`;
            } else {
                alert('No USB printers found');
                statusElement.textContent = 'No USB printers found';
                statusElement.className = 'connection-status disconnected';
            }
            this.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            this.disabled = false;
            statusElement.textContent = 'Scan error';
            statusElement.className = 'connection-status disconnected';
        });
});

// Manual connect
manualConnectBtn.addEventListener('click', function() {
    const address = manualAddressInput.value;
    const type = connectionTypeSelect.value;
    
    if (!address) {
        alert('Please enter a printer address');
        return;
    }
    
    this.disabled = true;
    statusElement.textContent = `Connecting to ${type} printer at ${address}...`;
    statusElement.className = 'connection-status searching';
    
    fetch('/api/printer/connect', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            address: address,
            method: type
        })
    })
    .then(response => response.json())
    .then(data => {
        updateConnectionStatus(data);
        this.disabled = false;
    })
    .catch(error => {
        console.error('Error:', error);
        this.disabled = false;
        statusElement.textContent = 'Connection error';
        statusElement.className = 'connection-status disconnected';
    });
});

// Print test
printTestBtn.addEventListener('click', function() {
    const firstName = firstNameInput.value;
    const lastName = lastNameInput.value;
    
    if (!firstName || !lastName) {
        alert('Please enter both first and last name');
        return;
    }
    
    this.disabled = true;
    
    fetch('/print-name', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            attendee_firstname: firstName,
            attendee_lastname: lastName
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('Error: ' + data.error);
        } else {
            alert('Print successful!');
        }
        this.disabled = false;
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error: ' + error);
        this.disabled = false;
    });
});

// Add reference to new button
const scanSystemBtn = document.getElementById('scan-system');

// Check for System printers
scanSystemBtn.addEventListener('click', function() {
    this.disabled = true;
    statusElement.textContent = 'Checking system printers...';
    statusElement.className = 'connection-status searching';
    
    fetch('/api/printer/scan/system', { method: 'POST' })
        .then(response => response.json())
        .then(data => {
            if (data.devices && data.devices.length > 0) {
                showDeviceList('System', data.devices);
                statusElement.textContent = `Found ${data.devices.length} system printer(s)`;
            } else {
                alert('No system printers found');
                statusElement.textContent = 'No system printers found';
                statusElement.className = 'connection-status disconnected';
            }
            this.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            this.disabled = false;
            statusElement.textContent = 'Scan error';
            statusElement.className = 'connection-status disconnected';
        });
});

// Initial status fetch
fetchStatus();

// Periodically update status
setInterval(fetchStatus, 5000);

================
File: templates/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Printer Connection Manager</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <h1>Brother Printer Connection Manager</h1>
    
    <div class="card">
        <h2>Connection Status</h2>
        <div id="connection-status" class="connection-status disconnected">
            Not connected
        </div>
        <div>
            <strong>Connection Method:</strong> <span id="connection-method">None</span>
        </div>
        <div>
            <strong>Printer Address:</strong> <span id="connection-address">None</span>
        </div>
        <div>
            <strong>Printer Model:</strong> <span id="printer-model">QL-820NWB1774</span>
        </div>
    </div>

    <div class="card">
        <h2>Connect to Printer</h2>
    <button id="auto-connect">Auto Connect (Try All Methods)</button>
    <button id="scan-system">Check System Printers</button>
    <button id="scan-wifi">Scan WiFi</button>
    <button id="scan-bluetooth">Scan Bluetooth</button>
    <button id="scan-usb">Check USB</button>
    
    <div id="device-container" style="display: none;">
        <h3>Available Devices</h3>
        <div id="device-list" class="device-list"></div>
    </div>
    </div>

    <div class="card">
        <h2>Manual Configuration</h2>
        <div>
            <label for="manual-address">Printer Address:</label>
            <input type="text" id="manual-address" placeholder="IP address, Bluetooth MAC, USB path, or system printer name">
            <select id="connection-type">
                <option value="system">System Printer</option>
                <option value="wifi">WiFi</option>
                <option value="bluetooth">Bluetooth</option>
                <option value="usb">USB</option>
            </select>
            <button id="manual-connect">Connect</button>
        </div>
    </div>

    <div class="card">
        <h2>Test Print</h2>
        <div class="test-print-form">
            <input type="text" id="first-name" placeholder="First Name">
            <input type="text" id="last-name" placeholder="Last Name">
            <button id="print-test">Print Name Tag</button>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
</body>
</html>

================
File: app.py
================
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS
import os
import importlib
import time
from threading import Thread
from PIL import Image, ImageDraw, ImageFont
import re

# Import our printer management modules
from printer_manager.scanner import scan_wifi_printers, scan_bluetooth_printers, check_usb_printers
from printer_manager.connection import test_printer_connection, update_print_module
import printer_manager.print_module as print_module

# Initialize Flask
app = Flask(__name__)
CORS(app)

# Create necessary directories
os.makedirs("static/css", exist_ok=True)
os.makedirs("static/js", exist_ok=True)
os.makedirs("templates", exist_ok=True)
os.makedirs("img", exist_ok=True)

# Global printer connection state
printer_state = {
    "connected": False,
    "method": None,
    "address": None,
    "model": "QL-820NWB1774",
    "status": "Not connected",
    "last_attempt": None
}

def auto_connect():
    """Try all connection methods in sequence"""
    global printer_state
    
    printer_state["status"] = "Searching for printers..."
    
    # First, try system printers as they're most reliable
    from printer_manager.scanner import get_system_printers
    printer_state["status"] = "Checking system printers..."
    system_printers = get_system_printers()
    for printer in system_printers:
        printer_state["status"] = f"Trying system printer {printer['address']}..."
        if test_printer_connection("system", printer['address'], printer_state["model"]):
            printer_state["connected"] = True
            printer_state["method"] = "system"
            printer_state["address"] = printer['address']
            printer_state["status"] = "Connected via system printer"
            printer_state["last_attempt"] = time.time()
            update_print_module(printer_state)
            return True
    
    # Next, try USB as it's next most reliable
    printer_state["status"] = "Checking USB connections..."
    usb_devices = check_usb_printers()
    for device in usb_devices:
        printer_state["status"] = f"Trying USB printer at {device['address']}..."
        if test_printer_connection("usb", device['address'], printer_state["model"]):
            printer_state["connected"] = True
            printer_state["method"] = "usb"
            printer_state["address"] = device['address']
            printer_state["status"] = "Connected via USB"
            printer_state["last_attempt"] = time.time()
            update_print_module(printer_state)
            return True
    
    # Next, try WiFi
    printer_state["status"] = "Scanning WiFi network..."
    wifi_devices = scan_wifi_printers()
    for device in wifi_devices:
        printer_state["status"] = f"Trying WiFi printer at {device['address']}..."
        if test_printer_connection("wifi", device['address'], printer_state["model"]):
            printer_state["connected"] = True
            printer_state["method"] = "wifi"
            printer_state["address"] = device['address']
            printer_state["status"] = "Connected via WiFi"
            printer_state["last_attempt"] = time.time()
            update_print_module(printer_state)
            return True
    
    # Finally, try Bluetooth
    printer_state["status"] = "Scanning Bluetooth devices..."
    bt_devices = scan_bluetooth_printers()
    for device in bt_devices:
        printer_state["status"] = f"Trying Bluetooth printer at {device['address']}..."
        if test_printer_connection("bluetooth", device['address'], printer_state["model"]):
            printer_state["connected"] = True
            printer_state["method"] = "bluetooth"
            printer_state["address"] = device['address']
            printer_state["status"] = "Connected via Bluetooth"
            printer_state["last_attempt"] = time.time()
            update_print_module(printer_state)
            return True
    
    # If all fails
    printer_state["connected"] = False
    printer_state["status"] = "No printers found"
    printer_state["last_attempt"] = time.time()
    return False

# API routes for printer connection management
@app.route('/api/printer/status', methods=['GET'])
def get_printer_status():
    return jsonify(printer_state)

@app.route('/api/printer/scan/system', methods=['POST'])
def handle_scan_system():
    """Get all printers installed in the system"""
    from printer_manager.scanner import get_system_printers
    devices = get_system_printers()
    return jsonify({"devices": devices})

@app.route('/api/printer/auto-connect', methods=['POST'])
def handle_auto_connect():
    thread = Thread(target=auto_connect)
    thread.daemon = True
    thread.start()
    return jsonify(printer_state)

@app.route('/api/printer/scan/wifi', methods=['POST'])
def handle_scan_wifi():
    devices = scan_wifi_printers()
    return jsonify({"devices": devices})

@app.route('/api/printer/scan/bluetooth', methods=['POST'])
def handle_scan_bluetooth():
    devices = scan_bluetooth_printers()
    return jsonify({"devices": devices})

@app.route('/api/printer/scan/usb', methods=['POST'])
def handle_scan_usb():
    devices = check_usb_printers()
    return jsonify({"devices": devices})

@app.route('/api/printer/connect', methods=['POST'])
def handle_connect():
    data = request.get_json()
    
    if 'address' not in data or 'method' not in data:
        return jsonify({"error": "Missing address or method"}), 400
    
    method = data['method']
    address = data['address']
    
    printer_state["status"] = f"Connecting to {method} printer at {address}..."
    
    if test_printer_connection(method, address, printer_state["model"]):
        printer_state["connected"] = True
        printer_state["method"] = method
        printer_state["address"] = address
        printer_state["status"] = f"Connected via {method.upper()}"
        printer_state["last_attempt"] = time.time()
        
        # Update the print module with the new connection
        update_print_module(printer_state)
    else:
        printer_state["connected"] = False
        printer_state["status"] = f"Failed to connect to {method} printer at {address}"
        printer_state["last_attempt"] = time.time()
    
    return jsonify(printer_state)

# Route for serving the main HTML page
@app.route('/')
def index():
    return render_template('index.html')

# Import the original create_image_with_name function and modify print_name to use our dynamic module
@app.route('/print-name', methods=['POST'])
def handle_print_name():
    try:
        # Check for Name in Request Body
        data = request.get_json()
        if 'attendee_firstname' not in data or 'attendee_lastname' not in data:
            # return error if the first and last name is missing
            return jsonify({"error": "Missing first or last name in request body"}), 400
        
        first_name = data['attendee_firstname']
        last_name = data['attendee_lastname']
        
        # Reload the print module to get any updates
        importlib.reload(print_module)
        
        # Create the image
        width, height = 696, 271
        image = Image.new("RGB", (width, height), "white")
        
        # Initialize the drawing context
        draw = ImageDraw.Draw(image)
        
        font_size = 128
        
        if(len(first_name) >= 8 or len(last_name) >= 8):
            longest_name = first_name if(len(first_name) > len(last_name)) else last_name 
            oversize = len(longest_name) - 8
            font_size = 128 - 12.32381 * oversize + 0.552381 * oversize ** 2
            print(font_size)
        
        # Check for the font, use default if not available
        try:
            font = ImageFont.truetype(font='./font/Dia-Black.ttf', size=int(font_size))
        except:
            # Use default font if the specified one is not available
            try:
                # Try to find a system font
                default_font = None
                if os.path.exists('/Library/Fonts/Arial.ttf'):  # macOS
                    default_font = '/Library/Fonts/Arial.ttf'
                elif os.path.exists('/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'):  # Linux
                    default_font = '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'
                elif os.path.exists('C:\\Windows\\Fonts\\Arial.ttf'):  # Windows
                    default_font = 'C:\\Windows\\Fonts\\Arial.ttf'
                
                if default_font:
                    font = ImageFont.truetype(font=default_font, size=int(font_size))
                else:
                    # If no system font found, use default PIL font
                    font = ImageFont.load_default()
            except:
                # Fallback to default PIL font
                font = ImageFont.load_default()
        
        # Calculate the width and height of the text to be drawn
        text_width, text_height = width, height
        
        # Calculate the position to draw the text so it's centered
        text_x = (width - text_width) / 2
        text_y = (height - text_height) / 2
        
        # Draw the text on the image
        draw.text((text_x, 0), first_name, fill="black", font=font)
        draw.text((text_x, text_height/2), last_name, fill="black", font=font)
        
        # Create path without whitespaces
        os.makedirs("./img", exist_ok=True)
        path = re.sub(r'\s+', '', f"./img/{first_name}{last_name}.png")
        
        # Save the image
        image.save(path)
        
        # Print using our dynamically loaded module
        print_success = print_module.print_name(path)
        
        if print_success:
            return jsonify({"message": "Print successful", "data": {"first_name": first_name, "last_name": last_name}}), 200
        else:
            return jsonify({"message": "Print failed, but image saved", "data": {"first_name": first_name, "last_name": last_name, "image_path": path}}), 202
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

@app.route('/attendee', methods=['POST'])
def handle_attendee():
    try:
        # Check for Id in Request Body
        data = request.get_json()
        if 'attendee_id' not in data:
            return jsonify({"error": "Missing 'id' in request body"}), 400
        
        attendee_id = data['attendee_id']
        
        # We need to import these here to avoid circular imports
        from eventbrite import Eventbrite
        
        eventbrite = Eventbrite('XLVSKCNWLRMMYJNREPKI')
        user = eventbrite.get(f'/events/789175203277/attendees/{attendee_id}')
        attendee_first_name = user['profile']['first_name']
        attendee_last_name = user['profile']['last_name']
        
        # This will need to be adapted to use the database functionality
        # from your original code
        # ...

        # For now, just print the name tag
        return handle_print_name_internal(attendee_first_name, attendee_last_name)
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

def handle_print_name_internal(first_name, last_name):
    """Internal version of handle_print_name without JSON parsing"""
    try:
        # Reload the print module to get any updates
        importlib.reload(print_module)
        
        # Create the image
        width, height = 696, 271
        image = Image.new("RGB", (width, height), "white")
        
        # Initialize the drawing context
        draw = ImageDraw.Draw(image)
        
        font_size = 128
        
        if(len(first_name) >= 8 or len(last_name) >= 8):
            longest_name = first_name if(len(first_name) > len(last_name)) else last_name 
            oversize = len(longest_name) - 8
            font_size = 128 - 12.32381 * oversize + 0.552381 * oversize ** 2
        
        # Check for the font, use default if not available
        try:
            font = ImageFont.truetype(font='./font/Dia-Black.ttf', size=int(font_size))
        except:
            # Use default font if the specified one is not available
            try:
                # Try to find a system font
                default_font = None
                if os.path.exists('/Library/Fonts/Arial.ttf'):  # macOS
                    default_font = '/Library/Fonts/Arial.ttf'
                elif os.path.exists('/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'):  # Linux
                    default_font = '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'
                elif os.path.exists('C:\\Windows\\Fonts\\Arial.ttf'):  # Windows
                    default_font = 'C:\\Windows\\Fonts\\Arial.ttf'
                
                if default_font:
                    font = ImageFont.truetype(font=default_font, size=int(font_size))
                else:
                    # If no system font found, use default PIL font
                    font = ImageFont.load_default()
            except:
                # Fallback to default PIL font
                font = ImageFont.load_default()
        
        # Calculate the width and height of the text to be drawn
        text_width, text_height = width, height
        
        # Calculate the position to draw the text so it's centered
        text_x = (width - text_width) / 2
        text_y = (height - text_height) / 2
        
        # Draw the text on the image
        draw.text((text_x, 0), first_name, fill="black", font=font)
        draw.text((text_x, text_height/2), last_name, fill="black", font=font)
        
        # Create path without whitespaces
        os.makedirs("./img", exist_ok=True)
        path = re.sub(r'\s+', '', f"./img/{first_name}{last_name}.png")
        
        # Save the image
        image.save(path)
        
        # Print using our dynamically loaded module
        print_success = print_module.print_name(path)
        
        if print_success:
            return jsonify({"message": "Print successful", "data": {"first_name": first_name, "last_name": last_name}}), 200
        else:
            return jsonify({"message": "Print failed, but image saved", "data": {"first_name": first_name, "last_name": last_name, "image_path": path}}), 202
    
    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5555, debug=True)

================
File: requirements.txt
================
attrs==23.2.0
blinker==1.8.2
brother-ql==0.9.4
certifi==2024.6.2
charset-normalizer==3.3.2
click==8.1.7
eventbrite==3.3.5
Flask==3.0.3
Flask-Cors==4.0.1
future==1.0.0
idna==3.7
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==2.1.5
packbits==0.6
pillow==10.4.0
pyusb==1.2.1
requests==2.32.3
urllib3==2.2.2
Werkzeug==3.0.3
netifaces==0.11.0
